<?php
/**
 * This file is part of the Makise-Co Framework
 *
 * World line: 0.571024a
 * (c) Dmitry K. <coder1994@gmail.com>
 */

declare(strict_types=1);

namespace MakiseCo\Database\QueryBuilder\Pgsql;

final class BindHelper
{
    private const STATEMENT_PARAM_REGEX = <<<'REGEX'
~(["'`])(?:\\(?:\\|\1)|(?!\1).)*+\1(*SKIP)(*FAIL)|(\$(\d+)|\?)|(?<!:):([a-zA-Z_][a-zA-Z0-9_]*)~ms
REGEX;

    /**
     * @param string $sql SQL statement with named and unnamed placeholders.
     * @param array $names [Output] Array of parameter positions mapped to names and/or indexed locations.
     *
     * @return string SQL statement with Postgres-style placeholders
     *
     * @copyright AMP Postgres
     */
    public static function parseNamedParams(string $sql, ?array &$names): string
    {
        $names = [];
        return \preg_replace_callback(self::STATEMENT_PARAM_REGEX, function (array $matches) use (&$names): string {
            static $index = 0, $unnamed = 0, $numbered = 1;

            if (isset($matches[4])) {
                $names[$index] = $matches[4];
            } elseif ($matches[2] === '?') {
                $names[$index] = $unnamed++;
            } else {
                $position = (int)$matches[3];
                if ($numbered++ !== $position) {
                    throw new \Error("Numbered placeholders must be sequential starting at 1");
                }

                $names[$index] = $unnamed++;
            }

            return '$' . ++$index;
        }, $sql);
    }

    /**
     * @param mixed[] $params User-provided array of statement parameters.
     * @param mixed[] $names Array generated by parseNamedParams.
     *
     * @return mixed[]
     *
     * @throws \Error If the $param array does not contain a key corresponding to a named parameter.
     *
     * @copyright AMP Postgres
     */
    public static function replaceNamedParams(array $params, array $names): array
    {
        $values = [];
        foreach ($names as $index => $name) {
            if (!\array_key_exists($name, $params)) {
                if (\is_int($name)) {
                    $message = \sprintf("Value for unnamed parameter at position %s missing", $name);
                } else {
                    $message = \sprintf("Value for named parameter '%s' missing", $name);
                }

                throw new \Error($message);
            }

            $values[$index] = static::cast($params[$name]);
        }

        return $values;
    }

    /**
     * Casts a PHP value to a representation that is understood by Postgres, including encoding arrays.
     *
     * @param mixed $value
     *
     * @return string|int|float|null
     *
     * @throws \Error If $value is an object without a __toString() method, a resource, or an unknown type.
     *
     * @copyright AMP Postgres
     */
    public static function cast($value)
    {
        switch ($type = \gettype($value)) {
            case "NULL":
            case "integer":
            case "double":
            case "string":
                return $value; // No casting necessary for numerics, strings, and null.

            case "boolean":
                return $value ? 't' : 'f';

            case "array":
                return static::array($value);

            case "object":
                if (!\method_exists($value, "__toString")) {
                    throw new \Error("Object without a __toString() method included in parameter values");
                }

                return (string)$value;

            default:
                throw new \Error("Invalid value type '$type' in parameter values");
        }
    }

    /**
     * Encodes an array into a PostgreSQL representation of the array.
     *
     * @param array $array
     *
     * @return string The serialized representation of the array.
     *
     * @throws \Error If $array contains an object without a __toString() method, a resource, or an unknown type.
     *
     * @copyright AMP Postgres
     */
    public static function array(array $array): string
    {
        $array = \array_map(function ($value) {
            switch (\gettype($value)) {
                case "NULL":
                    return "NULL";

                case "object":
                    if (!\method_exists($value, "__toString")) {
                        throw new \Error("Object without a __toString() method in array");
                    }

                    $value = (string)$value;
                // no break

                case "string":
                    return '"' . \str_replace(['\\', '"'], ['\\\\', '\\"'], $value) . '"';

                default:
                    return static::cast($value); // Recursively encodes arrays and errors on invalid values.
            }
        }, $array);

        return '{' . \implode(',', $array) . '}';
    }

    public static function escapeStringForSqlLike(string $str): string
    {
        return \str_replace(['%', '_' . '\\'], ['\\%', '\\_', '\\\\'], $str);
    }
}
